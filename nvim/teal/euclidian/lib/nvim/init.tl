
local a <const> = vim.api

local function failsafe(f: function, err_prefix: string): function()
	local ok = true
	local err: string
	return function()
		if ok then
			ok, err = pcall(f) as (boolean, string)
		end
		if not ok then
			a.nvim_err_writeln(err_prefix .. err)
		end
	end
end

local record UI
	chan: number
	height: number
	width: number
	rgb: boolean
	ext_cmdline: boolean
	ext_hlstate: boolean
	ext_linegrid: boolean
	ext_messages: boolean
	ext_multigrid: boolean
	ext_popupmenu: boolean
	ext_tabline: boolean
	ext_termcolors: boolean
	ext_wildmenu: boolean
end

local auto <const> = require("euclidian.lib.nvim._autogenerated")

local nvim <const> = {
	Window = auto.Window,
	Buffer = auto.Buffer,
	Tab = auto.Tab,

	UI = UI,
	MapOpts = auto.MapOpts,

	_exports: {string:function} = {},
}

function nvim.ui(n: number): UI
	return (a.nvim_list_uis() as {UI})[n or 1]
end

function nvim.openWin(b: nvim.Buffer, enter: boolean, c: nvim.Window.Config): nvim.Window
	local bufId <const> = b.id or 0
	local id <const> = a.nvim_open_win(bufId, enter, c)
	return nvim.Window(id)
end

function nvim.createBuf(listed: boolean, scratch: boolean): nvim.Buffer
	local id <const> = a.nvim_create_buf(listed, scratch)
	return nvim.Buffer(id)
end

function nvim.command(fmt: string, ...: any)
	a.nvim_command(string.format(fmt, ...))
end

local function to_str_arr(s: string | {string}): {string}
	if s is string then
		return {s}
	else
		return s
	end
end

function nvim.autocmd(s_events: string | {string}, s_patts: string | {string}, expr: string | function)
	local events <const> = table.concat(to_str_arr(s_events), ",")
	local patts <const> = table.concat(to_str_arr(s_patts), ",")
	
	assert(#events > 0, "no events")
	assert(#patts > 0, "no patterns")
	assert(expr, "no expr")

	local actual_expr: string
	if expr is string then
		actual_expr = expr
	else
		local key <const> = "autocmd" .. events .. patts
		nvim._exports[key] = failsafe(expr, "Error in autocmd: ")
		actual_expr = ("lua require'euclidian.lib.nvim'._exports[%q]()"):format(key)
	end

	nvim.command("autocmd %s %s %s", events, patts, actual_expr)
end

function nvim.augroup(name: string, lst: {{string | {string}, string | {string}, string | function}}, clear: boolean)
	nvim.command("augroup %s", name)
	if clear then
		nvim.command("autocmd!")
	end
	for _, v in ipairs(lst) do
		nvim.autocmd(v[1], v[2], v[3])
	end
	nvim.command("augroup END")
end

local function subLhs(lhs: string): string
	return (lhs:gsub("<.->", function(m: string): string
		local inner <const> = m:sub(2, -2):lower()
		if inner == "leader" then
			return a.nvim_get_var("mapleader") as string
		elseif inner == "esc" then
			return ""
		end
	end))
end

function nvim.setKeymap(mode: vim.Mode, lhs: string, rhs: string | function, userSettings: nvim.MapOpts)
	if rhs is string then
		a.nvim_set_keymap(mode, lhs, rhs, userSettings)
	else
		local key <const> = "keymap" .. mode .. subLhs(lhs)
		nvim._exports[key] = failsafe(rhs, "Error in keymap: ")
		a.nvim_set_keymap(
			mode,
			lhs,
			("<cmd>lua require'euclidian.lib.nvim'._exports[%q]()<cr>"):format(key),
			userSettings
		)
	end
end

function nvim.delKeymap(mode: vim.Mode, lhs: string)
	pcall(a.nvim_del_keymap, mode, lhs)
end

nvim.Buffer.setKeymap = function(self: nvim.Buffer, mode: vim.Mode, lhs: string, rhs: string | function, userSettings: nvim.MapOpts)
	if rhs is string then
		a.nvim_buf_set_keymap(self.id, mode, lhs, rhs, userSettings)
	else
		local key <const> = "bufkeymap" .. tostring(self.id) .. mode .. subLhs(lhs)
		nvim._exports[key] = failsafe(rhs, "Error in keymap: ")
		a.nvim_buf_set_keymap(
			self.id,
			mode,
			lhs,
			("<cmd>lua require'euclidian.lib.nvim'._exports[%q]()<cr>"):format(key),
			userSettings
		)
		nvim.command("autocmd BufUnload <buffer=%d> lua require'euclidian.lib.nvim'._exports[%q] = nil", self.id, key)
	end
end

nvim.Buffer.delKeymap = function(self: nvim.Buffer, mode: vim.Mode, lhs: string)
	pcall(a.nvim_buf_del_keymap, self.id, mode, lhs)
end

return nvim

