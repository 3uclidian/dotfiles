-- vim: ft=teal ts=3 sw=3

local record Func
	method: boolean
	name: string
	parameters: {{string}}
	return_type: string
	since: number
	deprecated_since: number
end
local record Type
	id: number
	prefix: string
end
local record Info
	error_types: {string:{string:number}}
	functions: {Func}
	types: {string:Type}
	ui_options: {string}
	record Version
		api_compatible: number
		api_level: number
		api_prerelease: boolean
		major: number
		minor: number
		patch: number
	end
	version: Version
end

local	record OptInfo
	name: string
	shortname: string
	type: string
	scope: string
end

local api_info = vim.fn.api_info() as Info

local pre <const> = [[
local a <const> = vim.api as {string:function}
local function unCamel(s: string): string
	return (s:gsub("[A-Z]", function(m: string): string
		return "_" .. m:lower()
	end))
end
local function genMetatable<T>(t: T, prefix: string): metatable<T>
	local cache <const>: {number:T} = {}
	return {
		__call = function(_: T, n: number): T
			if not n or n == 0 then
				n = a["nvim_get_current_" .. prefix]() as number
			end
			if not cache[n] then
				cache[n] = setmetatable({ id = n } as T, { __index = t })
			end
			return cache[n]
		end,
		__index = function(_: {string:function}, key: string): function
			local fn <const> = a["nvim_" .. prefix .. "_" .. unCamel(key)]
			return fn and function(self: {string:number}, ...: any): any
				return fn(self.id, ...)
			end
		end,
	}
end

local record MapOpts
	nowait: boolean
	silent: boolean
	script: boolean
	expr: boolean
	unique: boolean
	noremap: boolean
end
]]


do
	local typeMap <const>: {string:string} = setmetatable({
		["String"] = "string",
		["Number"] = "number",
		["Float"] = "number",
		["Integer"] = "number",
		["Boolean"] = "boolean",
		["Buffer"] = "number",
		["Window"] = "number",
		["Tabpage"] = "number",
		["Dictionary"] = "{string:any}",
		["Array"] = "{any}",
	}, {
		__index = function(): string
			return "any"
		end
	})

	local function getTypeName(name: string): string
		local tname: string
		if name:match("ArrayOf") then
			local arrayType = name:gsub("ArrayOf%((.*)%)", "%1")
			if arrayType:find(",") then
				local elementName, _size = arrayType:match("(%S+)%s*,%s*(%d+)")
				local size = tonumber(_size)
				elementName = typeMap[elementName]

				local tupleStr = {}
				for _ = 1, size do
					table.insert(tupleStr, elementName)
				end
				tname = "{" .. table.concat(tupleStr, ",") .. "}"
			else
				tname = "{" .. typeMap[arrayType] .. "}"
			end
		else
			tname = typeMap[name]
		end
		return tname -- .. "--[[" .. name .. "]]"
	end

	local ins <const> = table.insert

	local enum NamespaceName
		"Buffer"
		"Window"
		"Tab"
		"Nvim"
	end

	local record Namespace
		entries: {string}
		exclude: {string:boolean}
	end

	local namespaces: {NamespaceName:Namespace} = {
		["Buffer"] = {
			exclude = {
				getOption = true,
				setOption = true,
				call = true,
				setKeymap = true,
			},
			entries = {
				"call: function<T>(Buffer, function(): T): T",

				"getOption: function(Buffer, StringOpt): string",
				"getOption: function(Buffer, BooleanOpt): boolean",
				"getOption: function(Buffer, NumberOpt): number",
				"getOption: function(Buffer, string): number | boolean | string",

				"setOption: function(Buffer, StringOpt, string)",
				"setOption: function(Buffer, BooleanOpt, boolean)",
				"setOption: function(Buffer, NumberOpt, number)",
				"setOption: function(Buffer, string, number | boolean | string)",

				"setKeymap: function(Buffer, vim.Mode, string, string | function, MapOpts)",
			},
		},
		["Window"] = {
			exclude = {
				getOption = true,
				setOption = true,
				setConfig = true,
				getConfig = true,
			},
			entries = {
				[[record Config
		enum Anchor
			"NW" "NE" "SW" "SE"
		end
		enum Style
			"minimal"
		end
		enum Relativity
			"editor" "win" "cursor"
		end

		win: Id
		relative: Relativity
		anchor: Anchor
		row: number
		col: number
		width: number
		height: number
		bufpos: number
		focusable: boolean
		external: boolean
		style: Style
	end]],
				"getConfig: function(Window): Config",
				"setConfig: function(Window, Config)",

				"getOption: function(Window, StringOpt): string",
				"getOption: function(Window, BooleanOpt): boolean",
				"getOption: function(Window, NumberOpt): number",
				"getOption: function(Window, string): number | boolean | string",

				"setOption: function(Window, StringOpt, string)",
				"setOption: function(Window, BooleanOpt, boolean)",
				"setOption: function(Window, NumberOpt, number)",
				"setOption: function(Window, string, number | boolean | string)",
			},
		},
		["Tab"] = {
			exclude = {},
			entries = {},
		},
		["Nvim"] = {
			exclude = {},
			entries = {},
		},
	}

	local function camelCase(s: string): string
		return (s:gsub("%_(%w)", string.upper))
	end

	local function processDef(f: Func)
		if f.deprecated_since then return end
		local namespace: NamespaceName = "Nvim"
		local name: string
		if f.name:match("^nvim_buf_") then
			namespace = "Buffer"
			name = f.name:sub(10, -1)
		elseif f.name:match("^nvim_win_") then
			namespace = "Window"
			name = f.name:sub(10, -1)
		elseif f.name:match("^nvim_tabpage_") then
			namespace = "Tab"
			name = f.name:sub(14, -1)
		else
			name = f.name:sub(6, -1)
		end
		name = camelCase(name)
		local ns <const> = namespaces[namespace]
		if not ns.exclude[name] then
			local args <const>: {string} = {}
			for _, param in ipairs(f.parameters) do
				ins(args, getTypeName(param[1]))
			end
			if namespace ~= "Nvim" then
				args[1] = namespace
			end
			local ret <const> = f.return_type and f.return_type ~= "void"
				and getTypeName(f.return_type)
				or nil

			ins(ns.entries, name .. ": function(" .. table.concat(args, ", ") .. ")" .. (ret and ": " .. ret or ""))
		end
	end

	for _, f in ipairs(api_info.functions) do
		processDef(f)
	end

	local opts = vim.api.nvim_get_all_options_info() as {string:OptInfo}
	opts[""] = nil

	local wo: {string:{string}} = {
		["string"] = {},
		["boolean"] = {},
		["number"] = {},
	}

	local bo: {string:{string}} = {
		["string"] = {},
		["boolean"] = {},
		["number"] = {},
	}

	for _, opt in pairs(opts) do
		local tab: {string:{string}}
		if opt.scope == "win" then
			tab = wo
		elseif opt.scope == "buf" then
			tab = bo
		end
		if tab then
			table.insert(tab[opt.type], opt.name)
		end
	end

	local function addOpts(ns: Namespace, o: {string:{string}})
		for t, vals in pairs(o) do
			local out = {}
			ins(out, "enum " .. t:sub(1,1):upper() .. t:sub(2) .. "Opt")
			for _, entry in ipairs(vals) do
				ins(out, string.format("\t%q", entry))
			end
			ins(out, "end")
			table.insert(ns.entries, table.concat(out, "\n\t"))
		end
	end
	addOpts(namespaces["Window"], wo)
	addOpts(namespaces["Buffer"], bo)

	local nsToSnek = {
		["Window"] = "win",
		["Buffer"] = "buf",
		["Tab"] = "tabpage",
		["Nvim"] = "nvim",
	}

	local function processNs(ns: NamespaceName)
		print("local record " .. ns)
		print("\ttype Id = number")
		print("\tid: Id")
		print()
		for _, func in ipairs(namespaces[ns].entries) do
			print("\t" .. func)
		end
		print()
		print("\tmetamethod __call: function(" .. ns .. ", number): " .. ns)
		print("end")
		print(("setmetatable(%s, genMetatable(%s, %q))"):format(ns, ns, nsToSnek[ns]))
		print()
	end

	print(pre)
	processNs("Buffer")
	processNs("Window")
	processNs("Tab")

	print()
	print
[[
return {
	Buffer = Buffer,
	Window = Window,
	Tab = Tab,
	MapOpts = MapOpts,
}
]]
end

