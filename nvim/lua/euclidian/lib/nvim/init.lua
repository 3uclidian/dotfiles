
local a = vim.api

local function failsafe(f, err_prefix)
   local ok = true
   local err
   return function()
      if ok then
         ok, err = pcall(f)
      end
      if not ok then
         a.nvim_err_writeln(err_prefix .. err)
      end
   end
end

local UI = {}















local auto = require("euclidian.lib.nvim._autogenerated")

local nvim = {
   Window = auto.Window,
   Buffer = auto.Buffer,
   Tab = auto.Tab,

   UI = UI,
   MapOpts = auto.MapOpts,

   _exports = {},
}

function nvim.ui(n)
   return (a.nvim_list_uis())[n or 1]
end

function nvim.openWin(b, enter, c)
   local bufId = b.id or 0
   local id = a.nvim_open_win(bufId, enter, c)
   return nvim.Window(id)
end

function nvim.createBuf(listed, scratch)
   local id = a.nvim_create_buf(listed, scratch)
   return nvim.Buffer(id)
end

function nvim.command(fmt, ...)
   a.nvim_command(string.format(fmt, ...))
end

local function to_str_arr(s)
   if type(s) == "string" then
      return { s }
   else
      return s
   end
end

function nvim.autocmd(s_events, s_patts, expr)
   local events = table.concat(to_str_arr(s_events), ",")
   local patts = table.concat(to_str_arr(s_patts), ",")

   assert(#events > 0, "no events")
   assert(#patts > 0, "no patterns")
   assert(expr, "no expr")

   local actual_expr
   if type(expr) == "string" then
      actual_expr = expr
   else
      local key = "autocmd" .. events .. patts
      nvim._exports[key] = failsafe(expr, "Error in autocmd: ")
      actual_expr = ("lua require'euclidian.lib.nvim'._exports[%q]()"):format(key)
   end

   nvim.command("autocmd %s %s %s", events, patts, actual_expr)
end

function nvim.augroup(name, lst, clear)
   nvim.command("augroup %s", name)
   if clear then
      nvim.command("autocmd!")
   end
   for _, v in ipairs(lst) do
      nvim.autocmd(v[1], v[2], v[3])
   end
   nvim.command("augroup END")
end

local function subLhs(lhs)
   return (lhs:gsub("<.->", function(m)
      local inner = m:sub(2, -2):lower()
      if inner == "leader" then
         return a.nvim_get_var("mapleader")
      elseif inner == "esc" then
         return ""
      end
   end))
end

function nvim.setKeymap(mode, lhs, rhs, userSettings)
   if type(rhs) == "string" then
      a.nvim_set_keymap(mode, lhs, rhs, userSettings)
   else
      local key = "keymap" .. mode .. subLhs(lhs)
      nvim._exports[key] = failsafe(rhs, "Error in keymap: ")
      a.nvim_set_keymap(
      mode,
      lhs,
      ("<cmd>lua require'euclidian.lib.nvim'._exports[%q]()<cr>"):format(key),
      userSettings)

   end
end

function nvim.delKeymap(mode, lhs)
   pcall(a.nvim_del_keymap, mode, lhs)
end

nvim.Buffer.setKeymap = function(self, mode, lhs, rhs, userSettings)
   if type(rhs) == "string" then
      a.nvim_buf_set_keymap(self.id, mode, lhs, rhs, userSettings)
   else
      local key = "bufkeymap" .. tostring(self.id) .. mode .. subLhs(lhs)
      nvim._exports[key] = failsafe(rhs, "Error in keymap: ")
      a.nvim_buf_set_keymap(
      self.id,
      mode,
      lhs,
      ("<cmd>lua require'euclidian.lib.nvim'._exports[%q]()<cr>"):format(key),
      userSettings)

      nvim.command("autocmd BufUnload <buffer=%d> lua require'euclidian.lib.nvim'._exports[%q] = nil", self.id, key)
   end
end

nvim.Buffer.delKeymap = function(self, mode, lhs)
   pcall(a.nvim_buf_del_keymap, self.id, mode, lhs)
end

return nvim