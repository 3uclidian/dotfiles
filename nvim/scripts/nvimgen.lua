
local fh = assert(io.open("teal/euclidian/lib/nvim/_autogenerated.tl", "w"))
local function write(...)
   fh:write(...)
   fh:write("\n")
end

local Func = {}







local Type = {}



local Info = {Version = {}, }















local OptInfo = {}






local api_info = vim.fn.api_info()

local pre = [[
local record MapOpts
	nowait: boolean
	silent: boolean
	script: boolean
	expr: boolean
	unique: boolean
	noremap: boolean
end]]

local typeMap = setmetatable({
   ["String"] = "string",
   ["Number"] = "number",
   ["Float"] = "number",
   ["Integer"] = "integer",
   ["Boolean"] = "boolean",
   ["Buffer"] = "integer",
   ["Window"] = "integer",
   ["Tabpage"] = "integer",
   ["Dictionary"] = "{string:any}",
   ["Array"] = "{any}",
}, {
   __index = function()
      return "any"
   end,
})

local function getTypeName(name)
   local tname
   if name:match("ArrayOf") then
      local arrayType = name:gsub("ArrayOf%((.*)%)", "%1")
      if arrayType:find(",") then
         local elementName, _size = arrayType:match("(%S+)%s*,%s*(%d+)")
         local size = tonumber(_size)
         elementName = typeMap[elementName]

         local tupleStr = {}
         for _ = 1, size do
            table.insert(tupleStr, elementName)
         end
         tname = "{" .. table.concat(tupleStr, ",") .. "}"
      else
         tname = "{" .. typeMap[arrayType] .. "}"
      end
   else
      tname = typeMap[name]
   end
   return tname
end

local ins = table.insert

local NamespaceName = {}






local Namespace = {}




local namespaces = {
   ["Buffer"] = {
      exclude = {
         getOption = true,
         setOption = true,
         call = true,
         setKeymap = true,
      },
      entries = {
         "call: function<T>(Buffer, function(): T): T",

         "getOption: function(Buffer, StringOpt): string",
         "getOption: function(Buffer, BooleanOpt): boolean",
         "getOption: function(Buffer, NumberOpt): number",
         "getOption: function(Buffer, string): number | boolean | string",

         "setOption: function(Buffer, StringOpt, string)",
         "setOption: function(Buffer, BooleanOpt, boolean)",
         "setOption: function(Buffer, NumberOpt, number)",
         "setOption: function(Buffer, string, number | boolean | string)",

         "setKeymap: function(Buffer, vim.Mode, string, string | function, MapOpts)",
      },
   },
   ["Window"] = {
      exclude = {
         getOption = true,
         setOption = true,
         setConfig = true,
         getConfig = true,
      },
      entries = {
         [[record Config
		enum Anchor
			"NW" "NE" "SW" "SE"
		end
		enum Style
			"minimal"
		end
		enum Relativity
			"editor" "win" "cursor"
		end
		enum Border
			"none"
			"single"
			"double"
		end
	
		win: Id
		relative: Relativity
		anchor: Anchor
		row: integer
		col: integer
		width: integer
		height: integer
		bufpos: integer
		focusable: boolean
		external: boolean
		style: Style
		border: Border | { string | {string, string} }
	end]],
         "getConfig: function(Window): Config",
         "setConfig: function(Window, Config)",

         "getOption: function(Window, StringOpt): string",
         "getOption: function(Window, BooleanOpt): boolean",
         "getOption: function(Window, NumberOpt): number",
         "getOption: function(Window, string): number | boolean | string",

         "setOption: function(Window, StringOpt, string)",
         "setOption: function(Window, BooleanOpt, boolean)",
         "setOption: function(Window, NumberOpt, number)",
         "setOption: function(Window, string, number | boolean | string)",
      },
   },
   ["Tab"] = {
      exclude = {},
      entries = {},
   },
   ["Nvim"] = {
      exclude = {},
      entries = {},
   },
}

local function camelCase(s)
   return (s:gsub("%_(%w)", string.upper))
end

local function processDef(f)
   if f.deprecated_since then return end
   local namespace = "Nvim"
   local name
   if f.name:match("^nvim_buf_") then
      namespace = "Buffer"
      name = f.name:sub(10, -1)
   elseif f.name:match("^nvim_win_") then
      namespace = "Window"
      name = f.name:sub(10, -1)
   elseif f.name:match("^nvim_tabpage_") then
      namespace = "Tab"
      name = f.name:sub(14, -1)
   else
      name = f.name:sub(6, -1)
   end
   name = camelCase(name)
   local ns = namespaces[namespace]
   if not ns.exclude[name] then
      local args = {}
      for _, param in ipairs(f.parameters) do
         ins(args, getTypeName(param[1]))
      end
      if namespace ~= "Nvim" then
         args[1] = namespace
      end
      local ret = f.return_type and f.return_type ~= "void" and
      getTypeName(f.return_type) or
      nil

      ins(ns.entries, name .. ": function(" .. table.concat(args, ", ") .. ")" .. (ret and ": " .. ret or ""))
   end
end

for _, f in ipairs(api_info.functions) do
   processDef(f)
end

local opts = vim.api.nvim_get_all_options_info()
opts[""] = nil

local wo = {
   ["string"] = {},
   ["boolean"] = {},
   ["number"] = {},
}

local bo = {
   ["string"] = {},
   ["boolean"] = {},
   ["number"] = {},
}

for _, opt in pairs(opts) do
   local tab
   if opt.scope == "win" then
      tab = wo
   elseif opt.scope == "buf" then
      tab = bo
   end
   if tab then
      table.insert(tab[opt.type], opt.name)
   end
end

local function addOpts(ns, o)
   for t, vals in pairs(o) do
      local out = {}
      for _, entry in ipairs(vals) do
         ins(out, string.format("\t%q", entry))
      end
      table.sort(out)
      ins(out, "end")
      ins(out, 1, "enum " .. t:sub(1, 1):upper() .. t:sub(2) .. "Opt")
      table.insert(ns.entries, table.concat(out, "\n\t"))
   end
end
addOpts(namespaces["Window"], wo)
addOpts(namespaces["Buffer"], bo)

local function processNs(ns)
   write("local record " .. ns)
   write("\ttype Id = integer")
   write("\tid: Id")
   for _, func in ipairs(namespaces[ns].entries) do
      write("\t", func)
   end
   write(("\tmetamethod __call: function(%s, integer): %s"):format(ns, ns))
   write("\tmetamethod __eq: function(any, any): boolean")
   write("end")
end

write(pre)
processNs("Buffer")
processNs("Window")
processNs("Tab")

write([[
return {
	Buffer = Buffer,
	Window = Window,
	Tab = Tab,
	MapOpts = MapOpts,
}]])

fh:close()